<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      InnoDB源码解析-存储管理层次 | LoopJump&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 7.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>LoopJump's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>InnoDB源码解析-存储管理层次</h2>
  <p class="post-date">2022-06-03</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="InnoDB的存储层次"><a href="#InnoDB的存储层次" class="headerlink" title="InnoDB的存储层次"></a>InnoDB的存储层次</h2><p>总的数据粒度：Row - Page - Extent - Segment - Tablespace。</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-hierarchy.png" alt="innodb-storage-hierarchy.png"></p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><h3 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h3><p>行内容主要就是各列的值，外加一些flag信息。</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-row.png" alt="innodb-storage-row.png"></p>
<h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><p>Page(页面)是固定大小的物理存储块。Page有多种用途，既可以存放一组行记录，也可以存放存储管理元数据。</p>
<p>具体地，page类型相关的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/** File page types (values of FIL_PAGE_TYPE) @&#123; */</span><br><span class="line">#define FIL_PAGE_INDEX    17855 /*!&lt; B-tree node */</span><br><span class="line">#define FIL_PAGE_RTREE    17854 /*!&lt; B-tree node */</span><br><span class="line">#define FIL_PAGE_UNDO_LOG 2 /*!&lt; Undo log page */</span><br><span class="line">#define FIL_PAGE_INODE    3 /*!&lt; Index node */</span><br><span class="line">#define FIL_PAGE_IBUF_FREE_LIST 4 /*!&lt; Insert buffer free list */</span><br><span class="line">/* File page types introduced in MySQL/InnoDB 5.1.7 */</span><br><span class="line">#define FIL_PAGE_TYPE_ALLOCATED 0 /*!&lt; Freshly allocated page */</span><br><span class="line">#define FIL_PAGE_IBUF_BITMAP  5 /*!&lt; Insert buffer bitmap */</span><br><span class="line">#define FIL_PAGE_TYPE_SYS 6 /*!&lt; System page */</span><br><span class="line">#define FIL_PAGE_TYPE_TRX_SYS 7 /*!&lt; Transaction system data */</span><br><span class="line">#define FIL_PAGE_TYPE_FSP_HDR 8 /*!&lt; File space header */</span><br><span class="line">#define FIL_PAGE_TYPE_XDES  9 /*!&lt; Extent descriptor page */</span><br><span class="line">#define FIL_PAGE_TYPE_BLOB  10  /*!&lt; Uncompressed BLOB page */</span><br><span class="line">#define FIL_PAGE_TYPE_ZBLOB 11  /*!&lt; First compressed BLOB page */</span><br><span class="line">#define FIL_PAGE_TYPE_ZBLOB2  12  /*!&lt; Subsequent compressed BLOB page */</span><br><span class="line">#define FIL_PAGE_TYPE_UNKNOWN 13  /*!&lt; In old tablespaces, garbage in FIL_PAGE_TYPE is replaced with this value when flushing pages. */</span><br><span class="line">#define FIL_PAGE_COMPRESSED 14  /*!&lt; Compressed page */</span><br><span class="line">#define FIL_PAGE_ENCRYPTED  15  /*!&lt; Encrypted page */</span><br><span class="line">#define FIL_PAGE_COMPRESSED_AND_ENCRYPTED 16  /*!&lt; Compressed and Encrypted page */</span><br><span class="line">#define FIL_PAGE_ENCRYPTED_RTREE 17 /*!&lt; Encrypted R-tree page */</span><br></pre></td></tr></table></figure>

<p>一个<code>FIL_PAGE_INDEX</code>页面包含7部分：</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-fil-page-index.png" alt="innodb-storage-fil-page-index.png"></p>
<p><strong>Fil Header</strong></p>
<p>Fil Header总计占38字节，代码参见 include&#x2F;fil0fil.h</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-fil-header.png" alt="innodb-storage-fil-header.png"></p>
<p><strong>Page Header</strong></p>
<p>代码参见 include&#x2F;page0page.h</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-page-header.png" alt="innodb-storage-page-header.png"></p>
<h3 id="Extent"><a href="#Extent" class="headerlink" title="Extent"></a>Extent</h3><p>代码见 include&#x2F;fsp0fsp.h “EXTENT DESCRIPTOR”一节</p>
<p>引入Extent的主要目的是批量分配一段连续的page，提升分配效率和数据局部性。</p>
<p>Extent Descriptor是描述Extent属性的元数据信息，占用40字节，主要包括：</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-extent.png" alt="innodb-storage-extent.png"></p>
<p>Extent Descriptor本身也要存放到页面上，这个页面叫XDES Page（类型为<code>FIL_PAGE_TYPE_XDES</code>），一个Extent Descriptor也称为Extent Entry。</p>
<p>XDES Page的格式：</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-xdes.png" alt="innodb-storage-xdes.png"></p>
<h3 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h3><p>Segment是Page和Extent的资源集合，Segment可以管理extent和一些零散的page（最多32个）。</p>
<p>InnoDB中的索引对应两个segment：一个管理叶子节点，一个管理非叶子节点。</p>
<p>代码中，一个segment用inode entry这个数据结构来描述，参见include&#x2F;fsp0fsp.h中FILE SEGMENT INODE部分。</p>
<p>Inode entry信息包括：</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-inode-entry.png" alt="innodb-storage-inode-entry.png"></p>
<p>Segment元数据存放到类型为<code>FIL_PAGE_INODE</code>的页面上，页面内数据组织大致如下：</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-fil-page-inode.png" alt="innodb-storage-fil-page-node.png"></p>
<p>FSEG_INODE_PAGE_NODE：该字段用于串inode page链表。</p>
<h3 id="表空间-TableSpace"><a href="#表空间-TableSpace" class="headerlink" title="表空间 TableSpace"></a>表空间 TableSpace</h3><p><strong>共享表空间和独立表空间</strong></p>
<p>如果innodb_file_per_table配置为ON，则每个表都有自己的frm和ibd文件，也就是独立表空间。</p>
<p>共享表空间的优点：表空间自动管理，可以分成多个文件上存储。</p>
<p>共享表空间的缺点：不同表混合存储，删除操作可能导致大量空隙。</p>
<p>独立表空间的优点：存储方式清晰，故障恢复相对独立；跨库移动单表容易实现；空间回收更容易；删除操作更容易处理。</p>
<p>独立表空间的缺点：文件数量多，单表大小受限于操作系统单个文件大小。</p>
<p><strong>FSP Header</strong></p>
<p>源码参见 include&#x2F;fsp0fsp.h 中 ‘SPACED HEADER’ 部分。</p>
<p>表空间第一个Page是FSP Header，其类型是FIL_PAGE_TYPE_FSP_HDR。它是表空间的root page，创建表空间时初始化（fsp_header_init）。</p>
<p><img src="https://blogimage.loopjump.com/2022/innodb-storage-fsp.png" alt="innodb-storage-fsp.png"></p>
<h2 id="数据组织大图"><a href="#数据组织大图" class="headerlink" title="数据组织大图"></a>数据组织大图</h2><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="Tablespace"><a href="#Tablespace" class="headerlink" title="Tablespace"></a>Tablespace</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">DataFile主要描述tablespace的磁盘文件的信息。</span><br><span class="line"></span><br><span class="line">class DataFile</span><br><span class="line">&#123;</span><br><span class="line">  char* m_name;</span><br><span class="line">  char* m_filepath;</span><br><span class="line">  char* m_filename;</span><br><span class="line">  os_file_create_t m_open_flags;</span><br><span class="line">  ulint m_size;</span><br><span class="line">  ulint m_order; // ordinal position of this datafile in the tablespace</span><br><span class="line">  device_t m_type;</span><br><span class="line">  ulint m_space_id;</span><br><span class="line">  ulint m_flags;</span><br><span class="line">  bool m_exists; // true if file already existed on startup</span><br><span class="line">  byte* m_first_page_buf; // Buffer to hold first page</span><br><span class="line">  byte* m_first_page; // Pointer to the first page held in the buffer above</span><br><span class="line">  struct stat m_file_info;</span><br><span class="line">  pfs_os_file_t m_handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Tablespace</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;DataFile&gt; m_files;</span><br><span class="line">  char *m_name;</span><br><span class="line">  ulint m_space_id;</span><br><span class="line">  char *m_path;</span><br><span class="line">  ulint m_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dberr_t Tablespace::open_or_create(bool is_temp)</span><br><span class="line">|-- file_space_t *space = NULL;</span><br><span class="line">|-- ut_ad(!m_files.empty());</span><br><span class="line">|-- for (auto it : m_files)</span><br><span class="line">|---|-- if (it-&gt;m_exists)</span><br><span class="line">|---|---|-- it-&gt;open_or_create();</span><br><span class="line">|---|---|---|-- m_handle = os_file_create(innodb_data_file_key, m_filepath);</span><br><span class="line">|---|-- it-&gt;close();</span><br><span class="line">|---|-- if (it == m_files.begin())</span><br><span class="line">|---|---|-- flags = fsp_flags_set_page_size(0, univ_page_size); // 将page_size设置到fsp的flag</span><br><span class="line">|---|---|-- space = fil_space_create(m_name, m_space_id, flags, is_temp);</span><br><span class="line">|---|-- fil_node_create(it-&gt;m_filepath, it-&gt;m_size, space);</span><br><span class="line"></span><br><span class="line">fil_space_create(name, space_id, flags)</span><br><span class="line">|-- mutex_enter(fil_system-&gt;mutex);</span><br><span class="line">|-- space = fil_space_get_name(name); // 查fil_system-&gt;name_hash</span><br><span class="line">|-- assert(space == nullptr); // assert not exist</span><br><span class="line">|-- space = fil_space_get_by_id(id); // 查fil_system-&gt;spaces</span><br><span class="line">|-- assert(space == nullptr); // assert not exist</span><br><span class="line">|-- space = (fil_space_t*)malloc();</span><br><span class="line">|-- space-&gt;id = id;</span><br><span class="line">|-- space-&gt;name = name;</span><br><span class="line">|-- UT_LIST_INIT(space-&gt;chain, &amp;file_node_t::chain); // 初始化space-&gt;chain</span><br><span class="line">|-- HASH_INSERT(fil_space_t, hash, fil_system-&gt;space, id, space);</span><br><span class="line">|-- HASH_INSERT(fil_space_t, name_hash, fil_space-&gt;name_hash, name, space);</span><br><span class="line">|-- mutex_exit(fil_system-&gt;mutex);</span><br></pre></td></tr></table></figure>

<h3 id="创建filespace"><a href="#创建filespace" class="headerlink" title="创建filespace"></a>创建filespace</h3><p>用户新建表时，InnoDB会创建一个 “表名.ibd” 文件，并初始化filespace中的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">dict_build_tablespace_for_table(dict_table_t *table)</span><br><span class="line">|-- bool needs_file_per_table = DICT_TF2_FLAG_IS_SET(table, DICT_TF2_USE_FILE_PER_TABLE);</span><br><span class="line">|-- if (needs_file_per_table) // 每张表创建一个新的tablespace</span><br><span class="line">|---|-- space_id = dict_hdr_get_new_id(table);</span><br><span class="line">|---|-- table-&gt;space = space_id;</span><br><span class="line">|---|-- ulint fsp_flags = dict_tf_to_fsp_flags(table-&gt;is_tmep, table-&gt;is_encrypted, table-&gt;has_data_dir);</span><br><span class="line">|---|-- fil_make_filepath(fsp_flags, table-&gt;xx...dir, IBD); // 根据fsp_flags确定创建ibd filepath</span><br><span class="line">|---|-- // 这里会创建一个single-table tablespace，初始化是4个page。</span><br><span class="line">|---|-- // page 0: fsp header + extent descriptor;</span><br><span class="line">|---|-- // page 1: ibuf bitmap page;</span><br><span class="line">|---|-- // page 2: first inode page;</span><br><span class="line">|---|-- // page 3: 表的聚簇索引的root</span><br><span class="line">|---|-- fil_ibd_create(space, name, filepath, fsp_flags, FIL_IBD_FILE_INITIAL_SIZE);</span><br><span class="line">|---|---|-- os_create_file(filepath, name);</span><br><span class="line">|---|---|-- os_file_set_size(filepath, file, size * UNIV_PAGE_SIZE);</span><br><span class="line">|---|---|-- page = (byte*)malloc_aligned(UNIV_PAGE_SIZE);</span><br><span class="line">|---|---|-- fsp_header_init_fields(page, space_id, flags);</span><br><span class="line">|---|---|---|-- mach_write_to_4(FSP_HEADER_OFFSET + FSP_SPACE_ID + page, space_id);</span><br><span class="line">|---|---|---|-- mach_write_to_4(FSP_HEADER_OFFSET + FSP_SPACE_FLAGS + page, flags);</span><br><span class="line">|---|---|-- mach_write_to_4(page + FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID, space_id); // mach_write屏蔽大小端</span><br><span class="line">|---|---|-- buf_flush_init_for_writing(page);</span><br><span class="line">|---|---|-- os_file_write(page); // 将page刷到</span><br><span class="line">|---|-- mtr_start(&amp;mtr);</span><br><span class="line">|---|-- mtr.set_named_space(table-&gt;space);</span><br><span class="line">|---|-- fsp_header_init(table-&gt;space, FIL_IBD_FILE_INITIAL_SIZE, &amp;mtr);</span><br><span class="line">|---|-- mtr_commit(&amp;mtr);</span><br><span class="line">|-- else // 已经初始化过，设定下table的space_id即可</span><br><span class="line">|---|-- if (DICT_TF_HAS_SHARED_SPACE(table-&gt;flags))</span><br><span class="line">|---|---|-- ut_ad(table-&gt;space == fil_space_get_by_id(table-&gt;tablespace()));</span><br><span class="line">|---|-- else if (dict_table_is_temporary(table))</span><br><span class="line">|---|---|-- table-&gt;space = srv_tmp_space.space_id();</span><br><span class="line">|---|-- else</span><br><span class="line">|---|---|-- ut_ad(table-&gt;space == srv_sys_space.space_id());</span><br></pre></td></tr></table></figure>

<h3 id="分配Segment"><a href="#分配Segment" class="headerlink" title="分配Segment"></a>分配Segment</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* 入参page，如果指定了page(!=0)，表示要需要把inode entry的地址记录到page所指定的位置，</span><br><span class="line">如果不指定page(=0)，表示创建一个**独立**的segment，需要将inode entry的地址记录在segment的某个page中；*/</span><br><span class="line">fseg_create_general(space_id,</span><br><span class="line">                    ulint page,</span><br><span class="line">                    ulint byte_offset,</span><br><span class="line">                    mtr_t *mtr)</span><br><span class="line">|-- buf_block_t *block = buf_page_get(page_id_t(space_id, page), page_size, RW_SX_LATH, mtr); // 指定了page，则取出。</span><br><span class="line">|-- fseg_header_t *header = byte_offset + block-&gt;frame;</span><br><span class="line">|-- type = FIL_PAGE_TYPE_TRX_SYS / FIL_PAGE_TYPE_SYS;</span><br><span class="line">|-- space_header = fsp_get_space_header(space_id, page_size, mtr);</span><br><span class="line">|---|-- block = buf_page_get(page_id_t(space_id, 0), page_size, RW_SX_LATCH, mtr);</span><br><span class="line">|---|-- header = FSP_HEADER_OFFSET + block-&gt;frame;</span><br><span class="line">|-- inode = fsp_alloc_seg_inode(space_header, mtr);</span><br><span class="line">|-- seg_id = mach_read_from_8(space_header + FSP_SEG_ID);</span><br><span class="line">|-- mlog_write_ull(inode + FSEG_ID, seg_id, mtr); // 将数据写到page，且log该变更到mtr</span><br><span class="line">|-- mlog_write_ulint(inode + FSEG_NOT_FULL_N_USED, 0, MLOG_4BYTES, mtr);</span><br><span class="line">|-- flst_init(inode + FSEG_FREE, mtr); // 初始化free list</span><br><span class="line">|-- flst_init(inode + FSEG_NOT_FULL, mtr); // 初始化not_full list</span><br><span class="line">|-- flst_init(inode + FSEG_FULL, mtr); // 初始化full list</span><br><span class="line">|-- mlog_write_ulint(inode + FSEG_MAGIC_N, FSEG_MAGIC_N_VALUE, mtr);</span><br><span class="line">|-- for (int i = 0; i &lt; FSEG_FRAG_ARR_N_SLOTS; i++) // 初始化该segment的FSEG_FRAG_ARR_N_SLOTS(=32)个独立page</span><br><span class="line">|---|-- fseg_set_nth_frag_page_no(inode, i, FIL_NULL, mtr);</span><br><span class="line">|-- if (page == 0) // 入参page=0，表示segment的位置写在自己的某个page上</span><br><span class="line">|---|-- block = fseg_alloc_free_page_low(space_id, page_size, inode, mtr); // 分配一个page</span><br><span class="line">|---|-- header = byte_offset + block-&gt;frame;</span><br><span class="line">|---|-- mlog_write_ulint(block-&gt;frame + FIL_PAGE_TYPE, FIL_PAGE_TYPE_SYS, MLOG_2BYTES, mtr);</span><br><span class="line">|-- mlog_write_ulint(header + FSEG_HDR_OFFSET, page_offset(inode), mtr);</span><br><span class="line">|-- mlog_write_ulint(header + FSEG_HDR_PAGE_NO, page_get_page_no(page_align(inode), mtr);</span><br></pre></td></tr></table></figure>

<h3 id="分配Extent"><a href="#分配Extent" class="headerlink" title="分配Extent"></a>分配Extent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fsp_alloc_free_extent(space_id, page_size, page_no_t hint, mtr_t *mtr)</span><br><span class="line">|-- buf_block_t *desc_block = nullptr;</span><br><span class="line">|-- fsp_header_t *header = fsp_get_space_header(space_id, page_size, mtr);</span><br><span class="line">|-- xdes_t *descr = xdes_get_descriptor_with_space_hdr(header, space_id, mtr, &amp;desc_block);</span><br><span class="line">|-- fil_page_t *space = fil_space_get(space_id);</span><br><span class="line">|-- fil_block_check_type(desc_block, FIL_PAGE_TYPE_XDES, mtr);</span><br><span class="line">|-- if (descr &amp;&amp; xdes_get_state(descr, mtr) == XDES_FREE)</span><br><span class="line">|---|-- // ok, return this extent</span><br><span class="line">|-- else</span><br><span class="line">|---|-- first = fslt_get_first(header + FSP_FREE, mtr); // 取出FSP_FREE list第一个extent</span><br><span class="line">|---|-- if (fil_addr_is_null(first)) // FSP_FREE没有空闲的extent</span><br><span class="line">|---|---|-- fsp_fill_free_list(space, header, mtr); // 扩充空间******</span><br><span class="line">|---|---|-- first = fslt_get_first(header + FSP_FREE, mtr); // 扩充完再取出FSP_FREE list第一个extent</span><br><span class="line">|---|---|-- if (fil_addr_is_null(first)) // 扩展完还是没有空闲，返回失败</span><br><span class="line">|---|---|-- desc = xdes_lst_get_desriptor(space_id, page_size, first, mtr); // 获取xdes的地址</span><br><span class="line">|---|-- flst_remove(header + FSP_FREE, descr + XDES_FLST_NODE, mtr); // 更新FSP_FREE链表</span><br><span class="line">|---|-- space-&gt;free_len--;</span><br><span class="line">|-- return descr;</span><br></pre></td></tr></table></figure>

<h3 id="分配Page"><a href="#分配Page" class="headerlink" title="分配Page"></a>分配Page</h3><p>page的分配分为两种途径： 1）从全局的fsp上分配一个page，直接从FSP_FREE_FRAG或者FSP_FREE链表中分配一个extent，然后从这个extent中分配一个page。具体使用的场景包括分配inode page和为segment中的frag array分配page。 2）从segment中分配一个page。这种分配方式包括1），当segment中的frag array被填满时，会首先将全局的fsp上的extent分配给segment，然后再从已经分配segment的extent中寻找满足的条件的并分配page。</p>
<p>其实分配方式2）是供外部使用(比如BTree)的，通过fseg_alloc_free_page_general(这个对外的接口调用。</p>
<p><strong>从全局fsp上分配page</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">buf_block_t *fsp_alloc_free_page(space_id, page_size, page_no_t hint, rwlatch, mtr)</span><br><span class="line">|-- fsp_header_t *header = fsp_get_space_header(space_id);</span><br><span class="line">|-- xdes_t *descr = xdes_get_descriptor_with_space_hdr(header, page_size, mtr); // hint对应的extent</span><br><span class="line">|-- if (descr &amp;&amp; xdes_get_state(descr) == XDES_FREE_FRAG)</span><br><span class="line">|---|-- // ok, we can take this extent</span><br><span class="line">|-- else // hint page对应的extent没有空闲，则从FSP_FREE_FRAG/FSP_FREE链表中寻找有空闲page的extent</span><br><span class="line">|---|-- first = flst_get_first(header + FSP_FREE_FRAG, mtr);</span><br><span class="line">|---|-- if (fil_addr_is_null(first)) // FSP_FREE_FRAG链上没有free extent</span><br><span class="line">|---|---|-- descr = fsp_alloc_free_extent(space, page_size, hint, mtr);</span><br><span class="line">|---|---|-- xdes_set_state(descr, XDES_FREE_FRAG, mtr);</span><br><span class="line">|---|---|-- flst_add_last(header + FSP_FREE_FRAG, descr + XDES_FLST_NODE, mtr);</span><br><span class="line">|---|-- else</span><br><span class="line">|---|---|-- descr = xdes_lst_get_description(space, page_size, first, mtr);</span><br><span class="line">|-- // 从descr中分配一个page</span><br><span class="line">|-- free = xdes_find_bits(descr, XDES_FREE_BIT, mtr);</span><br><span class="line">|-- page_no = xdes_get_offset(descr) + free;</span><br><span class="line">|-- space_size = mach_read_from_4(header + FSP_SIZE);</span><br><span class="line">|-- if (space_size &lt;= page_no)</span><br><span class="line">|---|-- fil_space_t *fspace = fil_space_get(space);</span><br><span class="line">|---|-- if (!fsp_try_extend_data_file(space)) // no space to extend</span><br><span class="line">|---|---|-- return nullptr;</span><br><span class="line">|-- fsp_alloc_from_free_frag(header, descr, free, mtr); // 从descr中分配free位置的page</span><br><span class="line">|-- buf_block_t *ret_page = fsp_page_create(page_id_t(space, page_no), page_size, rwlatch, mtr); // 初始化这个page</span><br><span class="line">|-- return ret_page;</span><br></pre></td></tr></table></figure>

<p><strong>从segment上分配page</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf_block_t *fseg_alloc_free_page_general(fseg_header_t *seg_header, page_no_t hint, byte direction, mtr)</span><br><span class="line">|-- spcace_id = page_get_space_id(seg_header); // 读取space_id</span><br><span class="line">|-- space = mtr_x_lock_space(space_id, mtr); // 获取space对象</span><br><span class="line">|-- fseg_inode_t *inode = fseg_inode_get(seg_header, space_id, page_size, mtr, &amp;iblock); // 获取inode地址</span><br><span class="line">|-- fil_block_check_type(iblock, FIL_PAGE_INODE, mtr); // assert page type</span><br><span class="line">|-- block = fseg_alloc_free_page_low(space, page_size, inode, hint, direction, RW_X_LATCH, mtr); // 从seg中分配page</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>page分配策略</strong></p>
<p>page的分配按照以下策略一次去尝试分配.</p>
<ul>
<li>情况1: <strong>目标xdes</strong>(hint page所属的xdes)已经分配给当前segment，并且hint page处于空闲状态；</li>
<li>情况2: <strong>目标xdes</strong>是完全空闲状态，并且<strong>当前空间占用满足要求</strong>(已使用的page超过已经占用的page的7&#x2F;8,并且已使用的page数大于segment的frag array size)。那么将<strong>目标xdes</strong>分配给当前segment(能进入这个分支暗含的条件目标xdes不属于当前segment)，并将hint page分配出来。</li>
<li>情况3: 当direction不是FSP_NO_DIR(FSP_UP或FSP_DOWN, 这个条件用来限制是因为BTree分裂需要申请page，暂时先这样理解)，并且当前<strong>空间占用满足要求</strong>。那么从segment中分配一个free的extent(fseg_alloc_free_extent)，并分配extent中的第一个或者最后一个page，具体根据direction确定。</li>
<li>情况4: <strong>目标xdes</strong>已经属于给当前segment，并且处于未满的状态。那么从<strong>目标xdes</strong>中分配一个空闲的page</li>
<li>情况5: 当前segment中有空闲的page。那么寻找一个空闲的page分配出去，寻找的顺序是首先查找FSEG_NOT_FULL链表，再查找FSEG_FREE链表。</li>
<li>情况6: 当前使用的page数小于segment的frag array size。那么从table space中分配一个碎片page，并放在segment中相应的frag slot。</li>
<li>情况7: 兜底的情况，分配一个extent(fseg_alloc_free_extent)。如果extent是free状态，那么分配其第一个page，如果extent是free frag状态，那么分配第一个空闲的page。</li>
</ul>
<p>单独的去理解每一种情况并不能完整的理解整个分配策略，我们需要关注的是通过以上分配策略遵循那些原则，要达到那些效果？</p>
<p>原则 (优先级从高到低)： <strong>1</strong>、优先填满segment的frag array。 <strong>2</strong>、尽量使用已经分配给segment的空间，并使空间使用趋近于已使用的空间超过已占用空间的7&#x2F;8。 <strong>3</strong>、尽量分配hint page。</p>
<p>对照以上原则，我们对上述7种情况进行解读： 情况1暗含已经满足原则1(因为如果原则1没有满足，当前segment大概率不会有extent)，并且也满足原则2(从已经占用的空间上分配page)，当然很明显满足原则3。 情况2很明显是在瞒住原则1和原则2的前提下，去满足原则3。 情况3是在满足原则1和原则2，并且原则3已经确定无法满足的前提下，分配page …剩余几种情况供读者去理解，应该是很好对应的</p>
<p>效果 1、避免小表占用太多空间。 2、使实际占用空间接近实际需要的空间。 3、使逻辑相邻的数据，在物理上也尽可能相邻。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#MySQL" >
    <span class="tag-code">MySQL</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/innodb-trx-sys/">
        <span class="nav-arrow">← </span>
        
          InnoDB源码解析-事务系统
        
      </a>
    
    
      <a class="nav-right" href="/innodb-basic-struct/">
        
          InnoDB源码解析-基础数据结构
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#InnoDB%E7%9A%84%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1"><span class="toc-nav-text">InnoDB的存储层次</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-nav-text">数据格式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Row"><span class="toc-nav-text">Row</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Page"><span class="toc-nav-text">Page</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Extent"><span class="toc-nav-text">Extent</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Segment"><span class="toc-nav-text">Segment</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4-TableSpace"><span class="toc-nav-text">表空间 TableSpace</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%A4%A7%E5%9B%BE"><span class="toc-nav-text">数据组织大图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-nav-text">源码</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Tablespace"><span class="toc-nav-text">Tablespace</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%9B%E5%BB%BAfilespace"><span class="toc-nav-text">创建filespace</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%86%E9%85%8DSegment"><span class="toc-nav-text">分配Segment</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%86%E9%85%8DExtent"><span class="toc-nav-text">分配Extent</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%86%E9%85%8DPage"><span class="toc-nav-text">分配Page</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/innodb-storage-hierarchy/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2025 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
        <br>
        
            <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2023016451" target="_blank" rel="noopener nofollow"><img src="/css/images/ga.png" width="18" height="18"> 京公网安备 2023016451号</a>
        
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>