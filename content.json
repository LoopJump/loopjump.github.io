{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world/"},{"title":"Cwinux源码解析1","text":"Cwinux源码解析（一） Cwinux源码结构Cwinux源码包含三个部分：公共代码库cmn，同步网络库net，应用架构库app。 公共代码库cmn：cmn是Cwinux的基础代码库，实现了Cwinux平台的最基础的公共代码，包括线程池、TaskBoard（异步任务中使用）、Commander（负责将消息包发送到对应的处理句柄）、锁、内存池、package（对数据打包解包）、字符过滤、字符集定义等。 同步网络包net：net封装了网络层与传输层的TCP，UDP，Unix-Domain的协议。包括各自的网络地址对象、网络连接对象、网络连接建立对象、网络连接accept对象。net依赖cmn。 应用架构库app：app是Cwinux的Framework库，包含Framework，Channel等。app是Cwinux最终端的库，Cwinux使用者（网络服务开发者）继承app里的相关类，重载所关心的接口函数，实现自己的网络服务业务逻辑。app依赖cmn和net。 公共代码库cmn1. CwxBitMap位图工具类CwxBitMap实现了位图的基本操作：setBit将某一位设置为1，clrBit将某一位清零，检查某一位是否为1。CwxBitMap本身没有保存位图的数据，只提供操作函数。位图数据作为参数传递给操作函数。例如： 1234inline static void setBit(void* bitMap, CWX_UINT32 bit){ (((char*)bitMap)[bit&gt;&gt;3]) |= (1&lt;&lt;(bit&amp;0x07));} CwxBitMap用char数组来保存位图，每个char可以存放8位。置位时，首先跳到第 (bit&gt;&gt;3) 个char，然后将这个char的第 (bit&amp;0x07) 个位置1。另外，参数为void*类型，因此需要强转一次。 ps：淘宝的tbsys的BitMap类是将char数组作为类的成员变量保存在类中，再加上一些统计变量，这样可以快速提供已有多少位被置位，多少位清零。 2. CwxLogger日志类CwxLogger提供日志功能。 CwxLogger使用了懒汉模式的单实例模式。 CwxLogger日志类的几个主要成员变量包括日志输出级别m_uiLevel（info、debug、warning、error四个级别，可以设置输出全部或某几个级别的日志），日志文件大小和数量参数。CwxLogger还实现了日志文件的切换的循环使用（当前日志文件超过一定大小，切换到新的日志文件，日志文件数目超过一定数目，会重复使用最旧的日志文件）。 不少日志类（CwxLogger，tbsys.log）都使用内置宏__FILE__、__LINE__等来添加更丰富的信息。其中__FILE__指当前文件，__LINE__指当前行号。有了这些信息，使用日志文件时，能更清楚地知道某条日志是哪个源码文件的哪一行打印的。 3. CwxMutexLock，CwxMutexGuard等互斥锁相关类CwxMutexLock是互斥锁（排它锁）类。这个类主要对pthread库中的互斥锁类型pthread_mutex_t进行了封装，提供了申请锁、释放锁、尝试释放锁等。 CwxMutexGuard（Cwinux注释中称之为策略锁）封装了临界区的进入和退出。这是一个模板类。 1234567891011121314151617181920template &lt;class LOCK&gt;class CwxMutexGuard{public: ///构造函数，若lock不为空，则加锁 CwxMutexGuard (LOCK * lock):m_pLock(lock) { if (m_pLock) m_pLock-&gt;acquire(); } ///析构函数，若锁对象不为空，则解锁 ~CwxMutexGuard () { if (m_pLock) m_pLock-&gt;release(); }private: ///禁止不带锁对象的默认构造函数. CwxMutexGuard (): m_pLock (0) {} ///锁对象的指针 LOCK* m_pLock;}; 使用方式为： 123456789inline void append(CwxAppForkEnv* pForkEnv){ CwxMutexGuard&lt;CwxMutexLock&gt; lock(&amp;m_lock); if (pForkEnv) { m_forks.push_back(pForkEnv); m_bEvent = true; }} 该类包含一个LOCK模板对象m_pLock，具体可以是某个类型的锁。在CwxMutexGuard的构造函数中对m_pLock进行加锁，在析构函数中解锁。这样封装后，程序员不再手工调用lock和unlock函数，而是将其交给栈上对象的构造和析构函数负责。CwxMutexGuard的声明周期正好等于临界区。这样就能够保证在同一个函数中同一个scope中对某个互斥锁进行加锁和解锁。避免了在不同函数中、不同条件分支中、try-catch异常流程中加锁和解锁的麻烦。 4. CwxCondition条件变量类CwxCondition条件变量类对pthread库的条件变量pthread_cond_t进行了封装。封装过程比较简单，主要是对参数和返回值进行了一些处理。 pthread库的条件变量pthread_cond_t用法简述如下。 pthread_cond_t用于在执行一些动作前等待一个条件成立。例如，在使用了pthread_cond_t实现的生产者消费者问题中，生产者放入一个元素前需要等待“环形缓冲区中有空位置（读写指针指向的位置相同）”这一条件成立。 pthread_cond_t使用时需要和一个互斥锁mutex配合使用。mutex用于对条件的读写进行互斥保护。条件变量pthread_cond_t的使用模式比较固定，基本代码结构如下（代码中用cond表示条件变量）： wait端： 123456mutex.lock();while(waitCondition){ cond.wait(mutex);}mutex.unlock();Do Something 1... signal端： 1234mutex.lock();cond.signal();mutex.unlock();Do Something 2... 注：cond.wait(mutex)中会对mutex进行unlock，然后睡眠，等被唤醒后，重新mutex.lock，并从wait函数返回。所以从配对上看，显式的mutex.lock和mutex.unlock不是一对，它们跟wait中的unlock和lock分别是一对。wait中while用于避免虚假唤醒，即被唤醒后其实条件仍不满足（例如其他线程抢到了执行机会，条件又变得不满足了），此时应当继续wait。 CwxCondition类中包含了一个mutex的引用，该引用在CwxCondition的构造函数中被初始化。 5. CwxMsgQueue消息队列类CwxMsgQueue是一个阻塞的消息队列类，内部是一个CwxMsgBlock类型的消息对象的链表。在CwxMsgQueue中，没有消息为队列空条件，所有消息的大小超过一定预设值为队列满条件。CwxMsgQueue类包含了两个CwxCondition类型（条件变量类型）的成员变量m_notEmptyCond和m_notFullCond，用于表示队列非空和非满两个条件。 队列入队函数实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344inline int CwxMsgQueue::_waitNotFullCond(CwxTimeValue *timeout){ // Wait while the queue is full. while (this-&gt;_isFull()) { if (this-&gt;m_notFullCond.wait(timeout) == -1) { return -1; } if (this-&gt;m_state != ACTIVATED) { return -1; } } return 0;}///将一个消息放到队列的头部。-1：失败；&gt;=0：队列中的消息数量int CwxMsgQueue::enqueue (CwxMsgBlock *msg,CwxTimeValue *timeout){ int queue_count = 0; { CwxMutexGuard&lt;CwxMutexLock&gt; guard(&amp;this-&gt;m_lock); if (DEACTIVATED == this-&gt;m_state) { return -1; } if (this-&gt;_waitNotFullCond(timeout) == -1) return -1; if (!msg) return -1; m_curCount ++; m_curLength += msg-&gt;length(); m_curMsgBytes += msg-&gt;capacity(); msg-&gt;m_next = m_head; m_head = msg; if (!m_tail) m_tail = m_head; if (1 == m_curCount) { if (-1 == m_notEmptyCond.signal()) return -1; } queue_count = m_curCount; } return queue_count;} _waitNotFullCond中封装了条件变量m_notFullCond.wait操作。 enqueue函数中首先通过guard对this-&gt;m_lock加锁，然后调用_waitNotFullCond执行条件变量的wait。wait如果返回表示条件满足，开始执行具体的入队列动作，包括将新的消息对象串到链表中，修改统计信息等。如果这是第一个消息，也就是说队列从空变为不空，则调用m_notEmptyCond.signal()来唤醒等待队列不空这一条件的线程（这些线程在执行m_notEmptyCond.wait时，因为当时队列空而阻塞睡眠了）。 注意到，该代码没有显示表达出CwxCondition条件变量类中描述的“条件变量需要和一个互斥锁配合使用”的用法。这是因为CwxCondition类在内部包含了一个mutex的引用。例如，m_notFullCond操作在初始化时，它的成员变量mutex&amp;被初始化，后续m_notFullCond执行wait时，wait实现中会对该mutex加锁。 队列出队函数实现与入队相似。 6. CwxThread线程类CwxThread是对pthread线程的封装，注意到CwxThread类中包含一个CwxMsgQueue类型的对象。换言之，每个线程都能访问到某个消息队列。至于这个消息对象的来源，从CwxThread的构造函数可以看出，创建线程时可以指定一个已有的CwxMsgQueue对象作为该线程的消息队列，如果不指定，则构造函数负责创建一个新的消息队列。 spawn函数用来生成一个线程。该函数主要是进行pthread相关的设置，最后调用pthread_create函数创建线程。 start函数用来启动一个线程。start函数调用spawn函数，并将该线程将要执行的函数设置为threadFunc函数（函数指针作为参数传递给spawn函数）。threadFunc函数实际执行threadMain函数。 123456789101112131415161718192021222324252627282930313233343536void CwxThread::threadMain() { /* * 注册并设置 tss的相关代码。（略） */ m_pTssEnv-&gt;getThreadInfo().setThreadNo(m_unThreadId); /* * 线程实际执行代码 */ do { if (m_func) { //指定了线程执行的函数，则执行该函数 m_func(m_pTssEnv, m_msgQueue, m_arg); } else if (m_commander) { //未指定线程执行的函数，则通过Commander执行。 while( (iRet = this-&gt;pop(block)) != -1) //block until has query message { if (!m_commander-&gt;dispatch(block, m_pTssEnv, iRet)) { CWX_DEBUG(&quot;No handle to deal with event&quot;); } if (1 != iRet) { CWX_DEBUG(&quot;iRet = ???&quot;); } if (block) CwxMsgBlockAlloc::free(block); } } else { CWX_ERROR(&quot;Thread has neither commander nor own func, exit.&quot;); } }while(0);} threadMain首先进行必要的TSS设置（TSS指局部于线程的变量 thread specific storage），然后开始实际的工作。threadMain依据构造函数传递的参数不同，有两种工作方式。第一种是执行已指定的某个函数，这种方式比较简单，与未封装的pthread的用法基本一致。第二种是通过Commander这种机制来完成具体的功能。这种方式比较复杂，后面会有详细的介绍。这里先简单介绍一下。每个消息都有自己的类型， 每种类型的消息都有一个预设的操作对象来处理这个消息。Commander可以被视为类型到操作对象的映射关系管理者。当threadMain按第二种方式工作时，线程不断地从消息队列中取出消息，然后交给Commander处理。 7. CwxThreadPool，CwxThreadPoolEx线程池线程池的大致思路是：在服务启动时预先创建一定数目的线程，这些线程循环执行一些具体的工作，这样就避免了在每次处理你不同请求时进行创建线程和销毁线程。 Cwinux提供了两种线程池CwxThreadPool和CwxThreadPoolEx。回顾CwxThread类的实现，每个线程都能访问到某个消息队列。CwxThreadPool和CwxThreadPoolEx的区别如图示。 !http://loopjump.com/wp-content/uploads/2013/12/threadPool_newsize.jpg CwxThreadPool的所有线程共享一个消息队列。新的消息会追加到该消息队列。CwxThreadPoolEx的每个线程都有自己的消息队列，每个线程都只能从自己的消息队列中取出消息来处理。新的消息追加时需要制定具体追加到哪一个消息队列中。 线程池在创建并启动后，池中的所有线程会并发执行，从消息队列中读取消息，并依据线程的配置执行（参见CwxThread类的两种执行方式）。","link":"/Cwinux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/"},{"title":"Cwinux源码解析2","text":"8. CwxCommander命令模式等相关类前面在CwxThread线程类和CwxThreadPool/CwxThreadPoolEx线程池类中，描述了线程的两种执行方式。回顾如下： 线程依据构造函数传递的参数不同，有两种工作方式。第一种是执行已指定的某个函数，这种方式比较简单，与pthread的用法基本一致。第二种是通过Commander这种机制来完成具体的功能。这种方式比较复杂。 在Commander这种方式下，每个消息都有自己的类型， 每种类型的消息都有一个预设的操作对象来处理这个消息。Commander可以被视为类型到操作对象的映射关系管理者。当线程按Commander这种方式工作时，线程不断地从消息队列中取出消息，然后交给Commander分发处理。 Cwinux采用了Command设计模式，Commander等类就是具体的实现。 Command设计模式适用于如下的情形： 抽象出待执行的动作以参数化某对象。 在不同时刻指定、排列和执行请求。 支持取消操作。 支持修改日志。 Cwinux中，CwxCommander符合第一种情形。 对于第一种情形，例如，在Java GUI编程中，我们可以使用库中自带工具箱中的Menu类来添加一个菜单。该Menu类的开发者并不知道某个Menu的MenuItem对应的动作时什么，但可以指定一个Command类，这个Command类具有一个函数execute。Menu的使用者从Command派生一个子类ConcreteCommand，在ConcreteCommand的execute函数中实现具体的工作。这种例子中，Command模式是面向对象版本的回调函数机制。 Command的结构： !http://loopjump.com/wp-content/uploads/2014/01/Commander_pattern.gif CwxCommander，CwxCmdOp等类就是Cwinux中Command模式的实现。 在cmn/CwxCommander.h文件中定义了两个类 CwxCmdOp和CwxCommander。 CwxCmdOp代码如下： 12345678910111213141516171819202122232425262728class CWX_API CwxCmdOp{public: CwxCmdOp() { } virtual ~CwxCmdOp() { }public: virtual int onConnCreated(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) {} virtual int onConnClosed(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) {}/** @brief 收到通信数据包事件的处理函数。 @param [in] msg 收到通信数据包的事件对象。 @param [in] pThrEnv 线程的TSS对象。 @return -1：处理失败，0：不处理此事件，1：处理此事件。 */ virtual int onRecvMsg(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) { CWX_UNUSED_ARG(msg); CWX_UNUSED_ARG(pThrEnv); return 0; } virtual int onEndSendMsg(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) {} virtual int onFailSendMsg(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) {} virtual int onTimeoutCheck(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) {} virtual int onEvent4Handle(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) {} virtual int onUserEvent(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv) {}}; CwxCmdOp有若干个处理函数，当前这些处理函数不做任何有用的工作。这是Command模式中的Command类，这些onXXX函数就是Command类的execute函数（这里有多个不同的execute函数）。 具体使用时，Cwinux的使用者从CwxCmdOp继承一个具体的子类，例如CwxEchoEventHandler，然后实现所关心的execute函数（例如onRecvMsg函数）。 下面是CwxCommander类的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/**@class CwxCommander@brief Command类，基于事件的SVR-ID，实现事件与其处理Handle的映射。*/class CWX_API CwxCommander{ ///消息映射函数类型定义 typedef int (*fnEventApi)(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); ///SVR-ID与其处理Handle的映射Hash typedef hash_map&lt;CWX_UINT32, CwxCmdOp*, CwxNumHash&lt;CWX_UINT32&gt; &gt; CwxEventCommandHash;public: ///构造函数 CwxCommander():m_msgHash(1024) { m_arrEvent[CwxEventInfo::DUMMY] = NULL; m_arrEvent[CwxEventInfo::CONN_CREATED] = &amp;CwxCommander::onConnCreated; m_arrEvent[CwxEventInfo::CONN_CLOSED] = &amp;CwxCommander::onConnClosed; m_arrEvent[CwxEventInfo::RECV_MSG] = &amp;CwxCommander::onRecvMsg; m_arrEvent[CwxEventInfo::END_SEND_MSG] = &amp;CwxCommander::onEndSendMsg; m_arrEvent[CwxEventInfo::FAIL_SEND_MSG] = &amp;CwxCommander::onFailSendMsg; m_arrEvent[CwxEventInfo::TIMEOUT_CHECK] = &amp;CwxCommander::onTimeoutCheck; m_arrEvent[CwxEventInfo::EVENT_4_HANDLE] = &amp;CwxCommander::onEvent4Handle; m_arrEvent[CwxEventInfo::SYS_EVENT_NUM] = &amp;CwxCommander::onUserEvent; } ///析构函数 ~CwxCommander() { m_msgHash.clear(); }public: ///注册SVR-ID为uiSvrID的事件的处理函数。返回值，0:success, -1: 此SVR-ID已经存在 int regHandle(CWX_UINT32 uiSvrID, CwxCmdOp* pHandle); /** @brief 将消息分发给其处理Handle @param [in] msg 要分发的事件 @param [in] pThrEnv 线程的TSS对象。 @param [in] iRet Handle对消息的处理结果，-1：处理失败，0：指定的Handle不处理此事件，1：处理成功。 @return true：将消息分发给了指定的处理Handle；false：没有handle处理此消息 */ bool dispatch(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv, int&amp; iRet); ///清空Command注册的SVR-ID void reset() { m_msgHash.clear(); }private: /** @brief 将收到通信数据包事件分发给事件处理Handle。 @param [in] pEventOp 事件的处理Handle。 @param [in] msg 连接建立的事件对象。 @param [in] pThrEnv 线程的TSS对象。 @return -1：Handle处理失败，0：Handle不处理此事件，1：Handle成功处理此事件。 */ static int onRecvMsg(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); static int onConnCreated(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); static int onConnClosed(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); static int onEndSendMsg(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); static int onFailSendMsg(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); static int onTimeoutCheck(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); static int onEvent4Handle(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv); static int onUserEvent(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv);private: ///获取SVR-ID的处理Handle CwxCmdOp* getEventOp(CWX_UINT32 uiSvrID);private: fnEventApi m_arrEvent[CwxEventInfo::SYS_EVENT_NUM + 1];///事件类型与处理API的映射 CwxEventCommandHash m_msgHash;///&lt;事件SVR-ID与事件处理Hanlde的映射}; 首先，CwxCommander类的功能：基于事件的SVR-ID（消息包中带有这个属性），实现事件与其处理Handle的映射。 数据结构：既然是实现一个映射关系，自然是通过map数据结构。这里是使用的hash_map。代码中有如下代码片段： 12// SVR-ID与其处理Handle的映射Hashtypedef hash_map&lt;CWX_UINT32, CwxCmdOp*, CwxNumHash&lt;CWX_UINT32&gt; &gt; CwxEventCommandHash; 这段代码定义了一种类型，该类型类型名叫CwxEventCommandHash，它本质上是一个hash_map类型，hash_map的前两个模板是常用的Key的类型和Value的类型，第三个模板是用来指定一个哈希函数，hash_map在维护内部数据结构的时候使用这个哈希函数。注意到，CwxEventCommandHash的Key类型是CWX_UINT32，这是SVR-ID的类型。SVR-ID是每个消息包都有的一个属性，CwxCommander使用这个属性进行分发。CwxEventCommandHash的Value类型是CwxCmdOp*类型。通过这种方式，就将SVR-ID到CwxCmdOp映射关系记录下来了。 另外， typedef int (*fnEventApi)(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss pThrEnv);* 定义了一个函数指针类型（消息映射函数类型定义）。该函数指针指向的函数的参数是CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv三个参数，返回值是int型变量。 同时，代码fnEventApi m_arrEvent[CwxEventInfo::SYS_EVENT_NUM + 1];///事件类型与处理API的映射 定义了一个函数指针数组。该数组依据事件类型对应到不同的函数指针。事件类型也是每个消息包的一个属性。Cwinux中有若干中事件类型： 1234567891011 enum { DUMMY = 0,///&lt;dummy事件，此为无效事件类型 CONN_CREATED = 1,///&lt;连接建立事件 CONN_CLOSED = 2,///&lt;连接关闭事件 RECV_MSG = 3,///&lt;收到通信数据事件 END_SEND_MSG = 4,///&lt;通信数据包发送完毕事件 FAIL_SEND_MSG = 5,///&lt;通信数据包发送失败事件 TIMEOUT_CHECK = 6,///&lt;超时检查事件 EVENT_4_HANDLE = 7,///&lt;IO上注册的事件发生的事件 SYS_EVENT_NUM = 8,///&lt;系统事件的数量}; 这些事件类型会对应到CwxCommander的几个静态函数onRecvMsg，onConnCreated等（该对应关系在CwxCommander构造函数中设置）。每一个类型都对应于Command模式中的Command类的一个execute函数，这也是为何Cwinux中有多个execute函数。 好了，先暂停回顾一下。 每个消息都有SVR-ID和事件类型两个属性。 CwxCommander保存了SVR-ID到具体的CwxCmdOp的映射关系，同时每一个CwxCmdOp都有对应于不同事件类型的操作函数。 所以，每一个消息，交给CwxCommander后，CwxCommander能够依据消息的这两个属性找到一个具体的操作函数。 接着CwxCommander代码继续。 CwxCommander保存了SVR-ID到具体的CwxCmdOp的映射关系。在使用时，首先要先注册这种关系。regHandle就是实现这个功能。 123456789///注册SVR-ID为uiSvrID的事件的处理函数。返回值，0:success, -1: 此SVR-ID已经存在inline int CwxCommander::regHandle(CWX_UINT32 uiSvrID, CwxCmdOp* pHandle){ CWX_ASSERT(pHandle != NULL); if (this-&gt;getEventOp(uiSvrID)) return -1; this-&gt;m_msgHash[uiSvrID] = pHandle; return 0;} 其中，getEventOp是检查是否已经注册过了。代码如下： 123456789inline CwxCmdOp* CwxCommander::getEventOp(CWX_UINT32 uiSvrID){ CwxEventCommandHash::iterator iter = this-&gt;m_msgHash.find(uiSvrID); if (iter != this-&gt;m_msgHash.end()) { return iter-&gt;second; } return NULL;} CwxCommander的重头戏在dispatch函数。dispatch函数将消息分发给消息属性对应的（消息属性决定）Handle（CwxCmdOp的子类）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** @brief 将消息分发给其处理Handle @param [in] msg 要分发的事件 @param [in] pThrEnv 线程的TSS对象。 @param [in] iRet Handle对消息的处理结果，-1：处理失败，0：指定的Handle不处理此事件，1：处理成功。 @return true：将消息分发给了指定的处理Handle；false：没有handle处理此消息*/inline bool CwxCommander::dispatch(CwxMsgBlock*&amp; msg, CwxTss* pThrEnv, int&amp; iRet){ CwxCmdOp* pHandle = getEventOp(msg-&gt;event().getSvrId()); if (!pHandle) return false; if (msg-&gt;event().getEvent() &lt; CwxEventInfo::SYS_EVENT_NUM) { if (m_arrEvent[msg-&gt;event().getEvent()]) { iRet = (*m_arrEvent[msg-&gt;event().getEvent()])(pHandle, msg, pThrEnv); } else { iRet = 0; } } else { iRet = (*m_arrEvent[CwxEventInfo::SYS_EVENT_NUM])(pHandle, msg, pThrEnv); } return true;}// CwxCommander的几个操作的函数的实现。int CwxCommander::onConnCreated(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv){ return pEventOp-&gt;onConnCreated(msg, pThrEnv);}int CwxCommander::onConnClosed(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv){ return pEventOp-&gt;onConnClosed(msg, pThrEnv);}int CwxCommander::onRecvMsg(CwxCmdOp* pEventOp, CwxMsgBlock*&amp; msg, CwxTss* pThrEnv){ return pEventOp-&gt;onRecvMsg(msg, pThrEnv);} dispatch函数中，首先根据消息的SVR_ID属性查找对应的CwxCmdOp类型的Handle，然后根据消息的事件类型属性查找对应的操作函数，最后调用该操作函数（CwxCommander的几个静态函数）。CwxCommander的这几个静态函数实际执行的是Handle对应的操作函数。 综上，CwxCommander及相关类逻辑结构如图示。 !http://loopjump.com/wp-content/uploads/2014/01/Commander_newsize.jpg 结合线程池的实现，将上述内容概述如下： 用户（使用Cwinux的应用开发者）在应用初始化时建立线程池，并创建Commander。然后实现CwxCmdOp的子类XxxHandle用于处理消息。用户将XxxHandle注册到Commander中。用户从网络上接收到的消息包，并投入到线程池中的消息队列中。线程池会从消息队列中不断地读取消息并通过Commander方式执行dispatch函数将消息分发到具体的操作函数来处理该消息。","link":"/Cwinux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/"},{"title":"Cwinux简介","text":"Cwinux是什么2013年7、8月份，我在腾讯实习的时候，mentor安排我学习cwinux这个开源项目。实习期间阅读了cwinux项目的部分源代码，受益良多，现在写成博客分享交流，欢迎各位读者批评指正。 Cwinux是国人开源的一个Linux下的通信框架，C++语言编写。该框架（架构）内部集成了通信channel、信号处理、时钟处理、日志处理。 可以充分的利用多核的OS。通过此架构，可以方便地开发网络应用。 从这里可以下载源码： GoogleCode地址：http://code.google.com/p/cwinux/ 在OSChina上也有简介：http://www.oschina.net/p/cwinux 源码包里面除源码外，还包含了使用Cwinux的开发指南，一个使用Cwinux的例子和与apache/nginx/C语言的接口等。Cwinux的源码注释和文档非常规范详实，作者值得赞颂。 Cwinux最近一次更新时间是2013年7月份。基于Cwinux框架的其他项目有Unistor（key-value存储系统），cwinux-mq（消息队列）等。我在实习期间阅读的代码是2.3.7版本。本博客针对该版本的Cwinux进行了初步的源码解析，其中部分内容来自Cwinux官方文档。在解析源码之前，首先简单看看Cwinux的用法。这里以echo服务为例。 Cwinux echo例子Cwinux echo服务实现的功能为：启动服务后，建立监听，客户端向服务器发送一个字符串消息，服务器将该消息返回给客户端。 本文将简单描述Cwinux echo的结构，细节的描述请参考Cwinux开发手册第2章。 echo配置echo服务的配置文件是xml格式的，CwxEchoConfig类用来解析xml文件，获取配置参数。主要的配置参数包括工作目录，监听IP/Port等。 echo应用类CwxEchoApp类继承自CwxAppFramework。CwxAppFramework是Cwinux的内置类，代表一个应用。使用Cwinux开发网络服务应用时，用户都要从CwxAppFramework派生一个类，并重载（override）关心的函数。 CwxEchoApp类的代码精简后如下： 1234class CwxEchoApp : public CwxAppFramework{ int initRunEnv(); void onRecvMsg(...);}; initRunEnv函数初始化运行环境，其代码如下： 1234567891011121314151617181920212223int CwxEchoApp::initRunEnv(){ /* 设置系统的时钟间隔，最小刻度为1ms，此为1s。 设置工作目录 设置循环运行日志的数量 设置每个日志文件的大小 */ ///调用架构的initRunEnv，使以上设置的参数生效 CwxAppFramework::initRunEnv(); ///注册echo请求的处理handle，echo请求的svr-id为SVR_TYPE_ECHO m_eventHandler = new CwxEchoEventHandler(this); this-&gt;getCommander().regHandle(SVR_TYPE_ECHO, m_eventHandler); ///监听TCP连接，其建立的连接的svr-id都为SVR_TYPE_ECHO，接收的消息的svr-id都为SVR_TYPE_ECHO。全部由m_eventHandler对象来处理 this-&gt;noticeTcpListen(SVR_TYPE_ECHO,IP,PORT,MODE...); ///创建线程池对象，此线程池中线程的group-id为2，线程池的线程数量为m_config.m_unThreadNum。 m_threadPool = new CwxThreadPool(..., &amp;getCommander()); ///启动线程，线程池中线程的线程栈大小为1M。 m_threadPool-&gt;start(NULL));} 关于Commander: 每个消息都有自己的类型， 每种类型的消息都有一个预设的操作对象来处理这个消息。Cwinux框架中CwxCmdOp类是所有操作对象的父类。代码中的CwxEchoEventHandler就是继承自CwxCmdOp类。Commander可以被视为类型到操作对象的映射关系管理者。代码将SVR_TYPE_ECHO 类型的消息关联到CwxEchoEventHandler并将这个映射关系注册到Commander中，所有SVR_TYPE_ECHO类型的消息都会最终交给C wxEchoEventHandler来处理。 CwxEchoApp要重载该应用所关心的响应函数。响应函数是指框架收到事件通知时执行的处理函数，例如，框架收到消息包时会调用onRecvMsg函数，收到定时器事件时会调用onTime函数，收到信号事件时会调用onSignal函数。echo服务主要关心的是onRecvMsg函数。当echo服务收到消息时，框架会自动调用CwxEchoApp的onRecvMsg函数。开发者只需要重载这个函数，实现自己的业务逻辑（消息处理）就可以。 代码如下： 123456789101112131415int CwxEchoApp::onRecvMsg(CwxMsgBlock* msg, CwxAppHandler4Msg&amp; conn, CwxMsgHead const&amp; header, bool&amp; bSuspendConn){ msg-&gt;event().setSvrId(conn.getConnInfo().getSvrId()); msg-&gt;event().setHostId(conn.getConnInfo().getHostId()); msg-&gt;event().setConnId(conn.getConnInfo().getConnId()); msg-&gt;event().setIoHandle(conn.getHandle()); msg-&gt;event().setConnUserData(NULL); msg-&gt;event().setMsgHeader(header); msg-&gt;event().setEvent(CwxEventInfo::RECV_MSG); msg-&gt;event().setTimestamp(CwxDate::getTimestamp()); ///不停止继续接收 bSuspendConn = false; ///将消息放到线程池队列中，有内部的线程调用其处理handle（CwxEchoEventHandler）来处理 m_threadPool-&gt;append(msg); return 0;} Cwinux的架构比较复杂，处理了从最底层socket fd上读取并构造消息，创建线程池，分发消息，处理消息，以及更复杂的异步Task。除了整个架构比较复杂外，细节也比较多，例如，建立Tcp监听时有两种模式可选，对应的响应函数不同（一个由框架接收数据生成消息，另一个只是由框架通知有数据到来）。因此，个人以为，在使用Cwinux前最好先对源码有一些了解。 此外，单从学习角度看，Cwinux框架涉及到的Linux环境编程知识覆盖面广，用法典型，文档和注释都非常规范详实，是学习Linux环境编程的一个很好的材料。","link":"/Cwinux%E7%AE%80%E4%BB%8B/"}],"tags":[],"categories":[],"pages":[]}